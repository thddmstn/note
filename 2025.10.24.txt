와일드카드 마스크는 직관적으로 보기 어려워서 반드시 비트 계산이 필요하다.
 1) 와일드카드 마스크는 단순 범위가 아닌, "비트별 패턴"으로 작동하기 때문이다.
  (1) 단순히 "1.1.1.0 ~ 1.1.8.0"처럼 숫자 범위로 표현이 안 됨
  (2) 공통되는 비트는 0, 변하는 비트는 1로 표현해야 하므로 반드시 이진수 변환 후 분석 필요
 2) 모든 범위를 하나의 문장(와일드카드 하나)으로 표현할 수 없는 경우도 있음
  (1) 비트 단위의 비교라서 범위가 이진 구조에 딱 맞아떨어질 때만 하나의 문장으로 표현 가능
  (2) 그렇지 않으면 여러 문장으로 나눠야 함
 3) 와일드카드는 감으로 쓰지 말고, 무조건 비트 계산해야 한다
  (1) “딱 부러지게 설정하기 힘들고, 비트 계산 없이는 직관적으로 쓰기 어렵다”
  (2) 이건 Cisco에서도 인정하는 실질적인 약점이다.
 4) ACL 자동 생성기 (Online Tool & Script)
  (1) Cisco ACL Generator (online), SolarWinds IP Address Manager, Python 스크립트 등으로 생성
  (2) Python 스크립트


1. wildcard.py
-------------------------------------------------------------
import ipaddress
net = ipaddress.IPv4Network("192.168.0.0/22")
wildcard = '.'.join(str(255 - int(octet)) for octet in str(net.netmask).split('.'))
print(wildcard)  # 0.0.3.255
-------------------------------------------------------------



2) code
-------------------------------------------------------------
# 여러개 입력 스크립트
import ipaddress

# 입력: 여러 네트워크
cidrs = [
    "1.1.1.0/24",
    "1.1.2.0/24",
    "1.1.3.0/24",
    "1.1.4.0/24",
    "1.1.5.0/24",
    "1.1.6.0/24",
    "1.1.7.0/24",
    "1.1.8.0/24"
]

# 네트워크 주소들을 이진 문자열 리스트로 변환
bin_ips = []
for cidr in cidrs:
    net = ipaddress.IPv4Network(cidr)
    bin_str = ''.join(f"{int(octet):08b}" for octet in str(net.network_address).split('.'))
    bin_ips.append(bin_str)

# 공통 비트 계산
common_bits = ""
for bits in zip(*bin_ips):
    if all(b == bits[0] for b in bits):
        common_bits += bits[0]
    else:
        break

# 출력
print("공통 비트 수:", len(common_bits))
print("공통 비트:", common_bits)
print("CIDR 표현:", f"{ipaddress.IPv4Address(int(common_bits.ljust(32, '0'), 2))}/{len(common_bits)}")

# 와일드카드 마스크 계산
subnet_mask = ipaddress.IPv4Network(f"0.0.0.0/{len(common_bits)}").netmask
wildcard = '.'.join(str(255 - int(x)) for x in str(subnet_mask).split('.'))
print("와일드카드 마스크:", wildcard)
-------------------------------------------------------------

변수(variable) ---> 

"    " --->   '  를 이용하거나 문자열 처리를 해야 한다.  \"

select * from user where id='';
select * from user where id="";

- cat source   ( ASCII. 언어인지 확인)
인터프리터 (Interpreter) - 코드를 한 줄씩 읽어 즉시 실행하는 프로그램(코드를 볼 수 있다.) - HTML, PHP, Javascript, Python
컴파일 (Compile) - 소스 코드를 한 번에 기계어로 변환하는 것 - C, JAVA, C#...... 

- 시뱅(Shebang)
-a 옵션(option)” 또는 “인자(argument)”, “파라미터(parameter)”


언어(language) - (PHP, C, JAVA, go, ......   )




1. Opent Shortest Path First : 가장 짧은 경로(Band Width(링크) 기준 cost으로 경로 결정, 제일 적은 값)
 - OSPF는 링크 상태 기반의 내부 게이트웨이 프로토콜(IGP)로, 가장 짧은 경로를 계산하기 위해 Dijkstra(다익스트라)의 최단 경로 알고리즘을 사용한다.
 - 경로 결정 시 링크의 비용(Cost)을 기준으로 하며, 이 비용은 일반적으로 대역폭(Bandwidth)을 기반으로 계산된다. 대역폭이 클수록 비용은 낮아집니다.
 - 비용(Cost) 기준 적은 값이 우선이다.

2. Area (영역)
 - OSPF는 대규모 네트워크를 관리하기 위해 Area라는 개념을 도입했다.
 - OSPF 네트워크 내의 라우터는 기본적으로 같은 Area 내의 정보만 알며, 다른 Area의 라우팅 정보는 서머리제이션(Route Summarization)을 통해 축약된 형태로 전달된다.
 - Area 개념을 사용함으로써 OSPF는 라우팅 테이블 크기를 줄이고, 네트워크 성능을 최적화한다.

3. 백본 에어리어(Area 0)
 - Area가 2개 이상있을 대는 그중 하나는 반드시 백본 에어리어가 되어야 하고, 백본은 항상 0(0.0.0.0)이다.
 - 다른 Area 는 반드시 Area0에 연결되어 있어야 한다. (연결된 라우터를 ABR(Area Border Router) 라 불린다.)
 - ABR은 여러 Area 간에 라우팅 정보를 전달하며, Area 간의 경계 역할을 수행한다. 
 - Area0 을 기준으로 < 경계 > Area1 등 연결(Area0을 기준으로 연결되어야 한다.)
 - 모든 Area는 반드시 Area 0에 연결되어야 하지만, 물리적으로 Area 0에 직접 연결되지 않는 경우에는 가상 링크(Virtual Link)를 사용하여 연결할 수 있다.

4. 서머리제이션(Route Summarization)
1) Route Summarization(OSPF뿐만 아니라 다른 라우팅 프로토콜에서도 사용할 수 있는 개념)
 - Route Summarization은 여러 개의 개별 경로를 하나의 단일 경로로 통합하여, 라우팅 테이블 크기를 줄이고 네트워크의 성능을 향상시키는 기능이다.
 - 서머리제이션은 라우팅 테이블을 효율적으로 관리하고 전파하는 데 도움이 되며, 루프 방지, 대역폭 절약, 그리고 관리 용이성 등의 장점을 제공한다.
2)  Area Summarization(OSPF에서 특정 Area 간 경로를 요약할 때 주로 사용)
 - OSPF에서의 서머리제이션은 주로 ABR과 ASBR(Autonomous System Boundary Router)에서 수행된다. ABR은 Area 간의 경로 정보를 요약하여 전달하고, ASBR은 외부 경로를 요약하여 OSPF 도메인 내부에 전달한다.

5. Classful vs Classless Routing
 - Route Summarization은 과거 Classful Networking에서 IP 주소를 관리하기 위한 방법으로 시작되었지만, 현재는 Classless Inter-Domain Routing (CIDR)이 주로 사용되고 있다.
 - CIDR 방식에서도 서머리제이션은 여전히 중요한 역할을 하며, 특히 대규모 네트워크 관리에서 효율적인 주소 공간 할당과 라우팅 최적화에 중요한 기술이다.

6. OSPF의 기타 중요한 요소들
 - LSA (Link State Advertisement): OSPF는 네트워크 상태를 LSA를 통해 전파하며, 이는 각 라우터가 자신의 네트워크 링크 상태를 공유하는 방식이다.
 - DR/BDR (Designated Router/Backup Designated Router): 멀티 액세스 네트워크에서 네트워크 효율성을 위해 OSPF는 DR과 BDR을 사용하여 LSA 트래픽을 줄인다.
 - Metric 계산: OSPF의 기본 메트릭은 링크의 비용을 기준으로 하며, 이 비용은 100 Mbps 대역폭을 기준으로 계산되며, 링크 대역폭에 따라 다르게 설정된다. 예를 들어, 100 Mbps의 링크는 비용이 1이며, 10 Mbps는 비용이 10이다.


FULL Mesh : 네트워크 토폴로지 중 하나로, 모든 장비(노드)가 다른 모든 장비와 직접(서로간) 연결되어 있는 구조



Designated Router(DR, 지정된 라우터)  
 1) DR이 메인이되어(학급실장), 모든 라우터(개별)는 업데이트 정보를 DR에게 전달하고 DR이 모든 라우터에게 광고를 해준다.
 2) DR은 멀티액세스 네트워크에서 OSPF 라우터 간에 발생하는 LSA(Link State Advertisement, 광고) 트래픽을 줄이기 위해 선택된 라우터이다.
 3) 모든 라우터가 서로 LSA를 교환하는 대신, 모든 라우터가 DR과만 LSA를 교환한다.
 4) DR은 받은 LSA를 다른 라우터에게 전파하여, 트래픽을 효율적으로 관리한다.
 5) Backup Designated Router (BDR)도 함께 선출되며, DR이 다운될 경우 BDR이 DR 역할을 대신 수행한다.
 6) 라우터 우선순위(Interface priority) : 먼저 OSPF 인터페이스 우선순위 값(0-255)을 확인한다.
    기본값은 1이며, 이 값이 높을수록 DR로 선출될 가능성이 높다. 우선순위가 0인 경우 해당 라우터는 DR/BDR 후보, 제외한다.
 7) 라우터 ID(Router ID) : 만약 라우터 우선순위 값이 동일하다면, 라우터 ID 값이 가장 높은 라우터가 DR로 선출된다. 즉, 라우터 ID가 높은 라우터가 DR이 된다.
 8) 확인 방법 : Router# show ip ospf interface <인터페이스 이름>   (Priority 1 확인)
 9) 우선순위 변경
    Router(config)# interface <인터페이스 이름>
    Router(config-if)# ip ospf priority <우선순위 값>

3. 참고(clear)
 - clear ip route * : 라우팅 테이블을 초기화하고 재설정하여, 변경된 라우팅 정보가 반영되도록 한다.
 - clear ip ospf process : OSPF 프로세스를 재시작하여 OSPF 라우터 간의 새로운 네트워크 정보를 학습하도록 강제한다.


1. FULL/DR
FULL: OSPF 이웃 라우터 간의 데이터베이스가 완전히 동기화된 상태를 나타낸다. 즉, 두 라우터가 서로의 링크 상태 데이터베이스를 완전히 교환하고, 동일한 정보를 가지고 있다는 의미이다.
DR: Designated Router의 약자로, 멀티액세스 네트워크에서 OSPF 트래픽을 관리하는 역할을 한다. 이 상태는 DR이 포함된 링크 상태를 나타낸다.
2. EXSTART/DR
EXSTART: OSPF 이웃 라우터가 서로의 데이터베이스를 동기화하기 위한 과정의 첫 번째 단계이다. 이 단계에서는 두 라우터가 초기화된 데이터베이스의 ID를 서로 교환하고, 어떤 라우터가 DR 역할을 할 것인지 결정한다.
DR: 이 경우에도 Designated Router를 의미하며, EXSTART 단계에서 DR과 BDR(Backup Designated Router)의 역할이 정해진다.
3. FULL/DROTHER(DROTHER끼리는 광고를 하지 않는다.)
FULL: 이전과 같이 두 라우터의 데이터베이스가 완전히 동기화된 상태를 나타낸다.
DROTHER: 이웃 라우터가 DR이나 BDR이 아닌 경우를 의미한다. 즉, 이 라우터는 다른 이웃 라우터와 완전히 동기화되었지만, DR이나 BDR이 아니다.
- 요약
FULL/DR: DR과의 동기화가 완료된 상태.
EXSTART/DR: DR 선정 과정 중인 상태.
FULL/DROTHER: DR이나 BDR이 아닌 다른 라우터와 동기화된 상태.(DROTHER끼리는 광고를 하지 않는다.)



Default Route
라우팅 과정에서 라우팅 테이블에서 목적지를 찾지 못하면 해당 데이터는 DROP 한다.
이때 Default Route가 있다면 라우터가 라우팅 테이블에서 찾지 못한 네트워크는 전부 default route로 보낸다.

인터넷으로 통신할때 기본적으로 인터넷에서 인지할 수 있는 네트워크의 개수만 100만개 정도라고 한다면 라우터는 라우팅 테이블에 모든 인터넷에 있는 네트워크 정보를 가지고 있어야 할것인가? 이다. 

이런 문제를 해결하기 위해 Default Route를 사용한다.
Router(config)#route ospf 10
Router(config-router)#default-information originate


Router(config-router)#redistribute rip subnets
1) subnets 옵션은 클래스리스 서브넷(CIDR)을 포함시킨다. → 이게 없으면 클래스풀 네트워크만 OSPF에 넘겨지므로 중요한 옵션이다.
2) 라우터0가 RIP에서 배운 경로를 OSPF 10 프로세스에 재분배하여, OSPF를 사용하는 이웃 라우터들에게 그 경로를 광고한다

Router(config-router)#redistribute ospf 10 metric 5
OSPF 프로세스 10으로부터 배운 경로들을, RIP 라우팅 테이블에 넣고, RIP을 통해 다른 라우터들에게 광고함, metric 5: RIP의 hop count = 5 로 설정됨

Router(config-router)#redistribute eigrp 1 metric 3


Router(config-router)#redistribute rip metric 1544 2000 255 1 1500
 1) OSPF 와 재분배 : redistribute ospf 10 metric 1544 2000 255 1 1500
 2) EIGRP는 RIP과 달리 복합 메트릭(bandwidth, delay, reliability, load, MTU 등)을 사용하기 때문에 재분배 시 반드시 metric을 명시해 줘야 한다.
 3) metric 1544<bandwidth> 2000<delay> 255<reliability> 1<load> 1500<MTU>



Router(config-router)#redistribute static
Router(config-router)#redistribute connected 





뒤로 넘어오지 마라





access-list 10 deny 168.126.64.0 0.0.0.255
access-list 10 permit any
-----------------------------------------------------
ip access-list standard 10
deny 168.126.64.0 0.0.0.255

ip access-croup 10 in, out
access-class 10 in, out


168.126.64.2 IP 만 192.168.0.2 번으로 PING 허용

- 기본정책(차단)
Router(config)#access-list 100 permit ospf any any
Router(config)#access-list 100 permit icmp host 168.126.64.2 host 192.168.0.2
 - (생략가능)access-list 100 deny icmp any any 
 - 로그를 남기고 싶거나 할경우에는 정책을 적용해주면 된다.
Router(config)#int g0/0/0
Router(config-if)#ip access-group 100 out




192.168.0.2    21~80 접속 허용하시오
Router(config)#access-list 100 permit tcp any any established
Router(config)#access-list 100 deny tcp 168.126.65.2 0.0.0.0 host 192.168.0.2 eq 80
Router(config)#access-list 100 permit tcp any any range 21 80
Router(config)#access-list 100 deny tcp any any
Router(config)# int g0/0/0
Router(config-if)#ip access-group 100 out


Router(config)#ip access-list extended 100
Router(config-ext-nacl)#do sh acc
Extended IP access list 100
    10 permit tcp any any established (19 match(es))
    20 permit tcp any any range ftp www (5 match(es))
    30 deny tcp host 168.126.65.2 host 192.168.0.2 eq www
    40 deny tcp any any
Router(config-ext-nacl)#no deny tcp host 168.126.65.2 host 192.168.0.2 eq www
Router(config-ext-nacl)#15 deny tcp host 168.126.65.2 host 192.168.0.2 eq www
 - ftp, telnet, ssh, smtp, domain, www



R2(config)#int s0/2/0
R2(config-if)#ip nat outside
R2(config-if)#int f0/0
R2(config-if)#ip nat inside
R2(config-if)#exit
R2(config)#ip nat inside source static 192.168.100.10 204.200.7.1
R2(config)#end
R2#show ip nat ?
  statistics    Translation statistics
  translations  Translation entries
R2#show ip nat tra
R2#show ip nat translations 
Pro  Inside global     Inside local       Outside local      Outside global
---  204.200.7.1       192.168.100.10     ---                ---


DNAT(Destination NAT) 를 사용하기 위해서는
R2(config)#ip access-list standard private
R2(config-std-nacl)#permit 192.168.100.0 0.0.0.255
R2(config)#ip nat pool public 204.200.7.3 204.200.7.10 netmask 255.255.255.0
R2(config)#ip nat inside source list private pool public
R2(config)#int s0/2/0
R2(config-if)#ip nat outside
R2(config-if)#int f0/0
R2(config-if)#ip nat inside


SNAT(Source NAT)
R2(config)#ip access-list standard private
R2(config-std-nacl)#permit 192.168.100.0 0.0.0.255
R2(config-std-nacl)#ip nat pool public 204.200.7.3 204.200.7.3 netmask 255.255.255.0
R2(config)#ip nat inside source list private pool public overload
overload : PAT를 통해 하나의 공인 IP 주소를 다수의 내부 호스트가 공유한다.
R2(config)#int f0/0
R2(config-if)#ip nat inside
R2(config-if)#int s0/2/0
R2(config-if)#ip nat outside

  - Prefix 64bit, Host 64bit
  - prefix 는 기존 서브넷과 유사하며  48 / 64 / 128 등으로 표현한다.
  - 기존 bit는 사용가능하나 일반적으로 사용하지 않는다. 64bit 많이 사용

Router(config)#int g0/0/1
Router(config-if)#ipv6 address 1001:1:1:1::1/64
Router(config-if)#int g0/0/0
Router(config-if)#ipv6 address 1001:1:1:2::1/64


Router(config)#int g0/0/0
Router(config-if)#ipv6 address 1001:1:1:2::2/64
Router(config)#int g0/0/1
Router(config-if)#ipv6 address 1001:1:1:3::1/64
Router#ping 1001:1:1:2::1


ping 1001:1:1:3:2D0:58FF:FE36:A538

Router(config)#ipv6 router rip RIP1
Router(config-rtr)#int g0/0/0
Router(config-if)#ipv6 rip RIP1 ?
Router(config-if)#ipv6 rip RIP1 enable
Router(config-if)#int g0/0/1
Router(config-if)#ipv6 rip RIP1 enable

Router(config)#ipv6 router rip RIP2
Router(config-rtr)#int g0/0/0
Router(config-if)#ipv6 rip RIP2 enable
Router(config-if)#int g0/0/1
Router(config-if)#ipv6 rip RIP2 enable


Router(config)#ipv6 router ospf 1
%OSPFv3-4-NORTRID: OSPFv3 process 1 could not pick a router-id,please configure manually
로그 : OSPFv3 process 1 could not pick a router-id 
OSPFv3 는 라우터 ID를 결정할 수 없으므로 작동(결정)하지 않는다.
OSPF에서 router-id 는 라우터 이름이다. OSPFv3에서도 IPv4 주소기준으로 작동(결정)한다.
테스트 하는 라우터에는 IPv4 주소가 없으므로 IPv6, OSPFv3에서는 라우터 아이디를 임으로 주면 된다
Router(config-rtr)#router-id 1.1.1.1
Router(config-rtr)#int g0/0/1
Router(config-if)#ipv6 ospf 1 area 0
Router(config-if)#int g0/0/0
Router(config-if)#ipv6 ospf 1 area 0

Router(config)#ipv6 router ospf 2
Router(config-rtr)#router-id 2.2.2.2
Router(config-rtr)#int g0/0/0
Router(config-if)#ipv6 ospf 2 area 0
Router(config-if)#int g0/0/1
Router(config-if)#ipv6 ospf 2 area 0

Router#show ipv6 ospf neighbor 
Router#show ipv6 route

- 라우터는 주소를 수동으로 설정 가능하다.
eui-64 (호스트 부분은 맥주소로 결정한다.)










