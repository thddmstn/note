
vi 빌 조이
eamcs 리처드 스톨만
pico 워싱턴 대학
pico의 clone 버전 nano
nano GNU프로젝트
emacs 리처드 스톨만이 매크로기능
제임스 고슬링이 LISP언어 확장기능
vim 브람 무레나르



su -c "cat /etc/shadow" // shadow파일 내용 출력(root계정으로 실행됨)

su roror -c "cat /etc/shadow" // 허가 거부

su roror -c "cat /etc/passwd" // passwd파일 내용 출력

sudo -u roror cat /etc/shadow // 허가 거부

root@roror:/etc/pam.d# vi su
  5 auth            sufficient      pam_wheel.so trust use_uid  // wheel 그룹만 사용 가능, 패스워드 확인하지 않는다.)
  7 auth            required        pam_wheel.so use_uid  // wheel 그룹에 있는 사용자만 사용 가능, 패스워드 체크한다.)

root@roror:/home/roror# ls -l /usr/bin/su
-rwsr-xr-x. 1 root root 57336 2025년  2월 13일 /usr/bin/su

- (보안상)일반사용자가 사용자 전환을 하지 않을려면 su 권한을 수정해주자.
# chmod 700 /usr/bin/su


- sudo
roror group은 wheel에 속해있다
visudo 와 vi /etc/sudoers 같음  // 파일이름 확인
100 root    ALL=(ALL)       ALL
계정명 호스트명=(실행계정명) 명령어
108 %wheel ALL=(ALL)       ALL   // % 는 group이다.  
wheel이라는 group이 있고, 여기에 속해 있을 경우 wheel의 설정에 따라 실행 가능하다.
위의 내용을 보면 모든 권한을 부여 받았다.
위의 옵션을 주석처리하면 wheel goup은 사용할 수 없다.

이때 계정 사용자의 옵션을 주어야만 개별적 사용이 가능하다.

108 #%wheel ALL=(ALL)
roror@roror:~$ sudo cat /etc/shadow
[sudo] roror 암호: 
roror은(는) sudoers 파일에 없습니다.


107 #--------------------------------------------------------
108 Cmnd_Alias SAFE = /usr/bin/journalctl, /bin/systemctl status, /usr/bin/ss, /bin/ps
109 Cmnd_Alias DANGEROUS =
110 
111 roror   ALL=(ALL)       /bin/chown

/usr/bin/systemctl
/usr/sbin/ss
/usr/bin/ps


- shutdown, reboot, poweroff, reboot 만 사용할 수 없고, root 권한의 파일을 읽거나/수정 할 수 없도록 설정 하시오.
/usr/sbin/shutdown
/usr/sbin/reboot
/usr/sbin/poweroff


103 Cmnd_Alias SAFE = /usr/bin/journalctl, /bin/systemctl status, /usr/bin/ss, /bin/ps
104 Cmnd_Alias DANGEROUS = /usr/bin/cat, /usr/sbin/shutdown, /usr/sbin/reboot, /usr/sbin/poweroff
105 
106 roror   ALL=(ALL)      SAFE, !DANGEROUS, /bin/chown




100 root    ALL=(ALL)       ALL
101 Cmnd_Alias USERMGR =  /usr/bin/journalctl, /bin/systemctl status, /usr/bin/ss, /bin/ps, /usr/bin/safe-useradd, /usr/bin/safe-us
    ermod, /usr/bin/userdel
102 
103 %usermgr   ALL=(ALL)      USERMGR  

usermod -aG usermgr roror



- 시스템에서 root 로그인을 해야 할까?
 1) 로그인 하는 방법?
 2) 원격, 콘솔....... 
 3) 관리자 삭제(사용하지 않는다,) - 추후 관리자 권한이 필요할때가 있다. 4) 관리자로 로그인 하지 않고 관리자 명령을 사용하는 좋은 방법은
  - su?  sudo?

sudo
group에 적용, user에 적용, variable를 지정해서 사용

일부 명령어는 과도한 권한이 주어지므로 특정 명령만 사용하도록 추가 설정이 필요하다.
  - sudo vi, sudo nano,   관리자 권한으로 접근 수정이 가능하므로 주의가 필요
 - useradd, usermod  관리자 권한의 -o -u 0 -g 0 권한을 이용한 계정 생성이 가능하다.


roror@roror:~$ echo "useradd -o -u 0 -g 0 -s /bin/bash user3" > user.txt
roror@roror:~$ cat user.txt | grep -E '\-u\s*0'
useradd -o -u 0 -g 0 -s /bin/bash user3
roror@roror:~$ cat user.txt | grep -qE '\-u\s*0' // 결과 출력 안함 -q옵션
// \s 는 공백

vi /usr/bin/safe-useradd
  1 #!/bin/bash
  2 
  3 if echo "$@" | grep -qE -- '-u\s*0|-g\s*0|-o|-s';then
  4         echo "생성이 금지된 계정입니다."
  5         exit 1
  6 fi
  7 exec /usr/sbin/useradd "$@"

- or 
ls || cat /etc/passwd   // 양쪽이 정상이어도 처음이 실행되면 끝남

-and
ls && false   // ls 만 실행됨
false && ls   // 둘 다 실행 안됨


내부 명령어 : shell에 내장되어있음
외부 명령어 : /bin, /sbin 에 파일 형태로 존재

echo "$PWD" --> /home/roror
echo '$PWD' --> $PWD

head/tail
-n 3 == -3   
-f 실시간 출력


sort / uniq



systmed-networkd 
  - systemd-networkd가 관리하는 네트워크 인터페이스들이 "완전히 연결될 때까지" 기다리는 서비스 이다.
  - 서버 환경에서는 부팅 직후 네트워크가 준비 안 되면 문제를 일으킬 수 있으므로, 안정성을 위해 기본 활성화돼 있다.


- Snort(NFQ) - NAT
Ubuntu - ifupdown, NetworkManager(nmcli), systemd, netplan

root@elk:/# systemctl list-unit-files --state=enabled | grep networkd

root@elk:/# systemctl list-unit-files | grep networkd

root@elk:/# systemctl list-unit-files | grep NetworkManager

root@elk:/# dpkg -L netplan.io

root@elk:/# dpkg -l | grep netplan

root@elk:/# dpkg -l netplan.io


/etc/network (ifupdown)
root@elk:/etc/network# ls
if-down.d  if-post-down.d  if-pre-up.d  if-up.d

root@kali:/etc/network# ls
if-down.d  if-post-down.d  if-pre-up.d  if-up.d  interfaces  interfaces.d
// interfaces  (기본 설정, address 10.0.0.200... 형식으로 작성한다.)
auto eth0
iface eth0 inet static


vi /etc/network/interfaces  kali
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback


vi /etc/network/interfaces  (Meta)
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet dhcp

- Debian  계열에서 ifupdown 방식을 기본으로 사용했다. 
18 버전 이후부터 NetworkManager, systemd, netplan 방식을 사용한다.

Kali Linux 는 설정에 따라  nmcli, ifupdown 으로 사용 가능.

-netplan
/etc/netplan
ens33
ens36
vi /etc/netplan/50-cloud-init.yaml
network:
  version: 2
  ethernets:
    ens33:
      addresses: 
        - 10.0.0.222/24
      routes:
        - to: default
          via: 10.0.0.1
      nameservers:
        addresses: [10.0.0.200,8.8.8.8,8.8.4.4]
    ens36:
      addresses:
        - 192.168.1.1/24
root@elk:/etc/netplan# netplan apply

/etc/resolv.conf
대부분 해당 파일을 참고하여 DNS 서버를 찾았으나, 최근 Ubuntu에서는 systemd-resovd를 사용한다. (캐쉬처럼, 도메인을 해석해주는 모듈이다.)
DNS 변조를 방어해준다. 다만 VPN, 프록시 등 쿼리를 적절하게 라우팅해야 하는 프로그램에서는 사용상 설정이 어려울 수 있다.


root@elk:/home/roror# vi /etc/systemd/resolved.conf 
DNS=10.0.0.200
FallbackDNS=8.8.8.8

root@elk:/home/roror# systemctl status systemd-resolved
root@elk:/home/roror# systemctl restart systemd-resolved

/run/systemd/resolve/stub-resolv.conf


root@elk:/home/roror# systemctl list-unit-files | grep networkd
networkd-dispatcher.service                  enabled         enabled
systemd-networkd-wait-online.service         disabled        enabled
systemd-networkd-wait-online@.service        disabled        enabled
systemd-networkd.service                     disabled        enabled
systemd-networkd.socket                      disabled        enabled
root@elk:/home/roror# systemctl list-unit-files | grep Network
NetworkManager-dispatcher.service            enabled         enabled
NetworkManager-wait-online.service           disabled        enabled
NetworkManager.service                       enabled         enabled

// NetworkManager-wait-online.service  랜카드가 정상인가 체크, ens36에 아이피 없음--> 오류


/etc/resolv.conf 파일을 이용해서 사용하고 싶을때는 systemd-resolved 를 중지 시켜야 한다.
 대부분 해당 파일을 참고하여 DNS 서버를 찾았으나. 최근 Ubuntu 에서는 systemd-resolvd 를 사용한다. (캐쉬처럼, 도메인을 해석해주는 모듈이다.)
 DNS 변조를 방어해준다. 다만. VPN, 프록시 등 쿼리를 적절하게 라우팅해야 하는 프로그램에서는 사용상 설정이 어려울 수 있다.

# systemctl status systemd-resolved  (기본으로 되어 있다.)
/etc/resolv.conf -->  /run/systemd/resolve/stub-resolv.conf  (nameservers 127.0.0.53)

- (systemd-resolved)수동으로 DNS 지정하고 싶을때
# vi /etc/systemd/resolved.conf  (순서를 지정하면 된다.)

# systemctl disable --now systemd-resolved


Debian 방화 : ufw, firewalld(Redhat), iptables


root@elk:/home/roror# vi /etc/iptables.conf
---------------------------------------------------------------------------------------
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
# -A POSTROUTING -s 192.168.123.0/24 -o enp0s6 -j MASQUERADE     # 외부 IP DHCP시
# -A POSTROUTING -s 10.0.0.0/24 -o enp0s6 -j SNAT --to-source 192.168.64.12   # 외부 IP STATIC 구현시
# -A PREROUTING -d 192.168.64.12 -p TCP --dport 80 -j DNAT --to 10.0.0.2:80
#-A PREROUTING -d 192.168.123.222 -p TCP --dport 21:443 -j DNAT --to 10.0.0.100 
COMMIT

*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [66:8043]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
#-A FORWARD -j NFQUEUE --queue-num=4
#-A INPUT -p icmp --icmp-type echo-request -j NFQUEUE --queue-num=4
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 5000:6000 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 1:65000 -j DROP
-A INPUT -p udp -m state --state NEW -m udp --dport 1:65000 -j DROP
#-A INPUT -j REJECT --reject-with icmp-host-prohibited
#-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT
---------------------------------------------------------------------------------------
- 위의 내용을 방화벽 정책이라 할 수 있다.
root@elk:/home/roror# iptables -nL  (리스트 출력)


???내가 뭘 한거지


root@elk:/home/roror# vi /etc/apache2/sites-enabled/000-default.conf 
  9         ServerName elk.roror.co.kr
 10         
 11         ServerAdmin webmaster@localhost
 12         DocumentRoot /var/www/html
 13 

10.0.0.222 접속


root@elk:/home/roror# iptables-restore /etc/iptables.conf   // 방화벽 정책
10.0.0.222 접속 안됨

- iptables 방화벽, kernel(netfilter)

vi /etc/iptables.conf
 20 -A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT
 21 -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
 22 -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT  // 추가
 23 -A INPUT -p tcp -m state --state NEW -m tcp --dport 5000:6000 -j ACCEPT
 24 -A INPUT -p tcp -m state --state NEW -m tcp --dport 1:65000 -j DROP
 25 -A INPUT -p udp -m state --state NEW -m udp --dport 1:65000 -j DROP


root@elk:/home/roror# iptables -F   // 정책 해제, 비워버림. 초기화..
root@elk:/home/roror# iptables-restore /etc/iptables.conf   // iptables.conf 파일 읽어서 정책 적용

- 대부분의 리눅스가 사용했던 디렉토리(부팅과 관련된 스크립트)
- 최근! Redhat 계열에서는 사용하지 않는다.
- /etc/init.d/
- /etc/rc*.d/ 
- /etc/rc.d/init.d
- /etc/init.d/

0, 1, 3, 5, 6  
0 종료
3 Multi - CUI/TUI
5 GUI
6 재부팅
# systemctl set-default multi-user.target   // runlevel 3
# systemctl get-default
# systemctl set-default graphical.target    // runlevel 5

root@roror:/home/roror# systemctl set-default multi-user.target 
root@roror:/home/roror# systemctl get-default 
multi-user.target   // runlevel을 보여줌


/etc/init.d/ssh stop  (start|stop|restart)   --->  metasploitable2 
/etc/rc5.d  --->   /etc/init.d 파일을 심볼릭으로 가리키고 있다.

root@elk:/etc/rc5.d# ls
K01apache-htcacheclean  S01dbus           S01snort
K01speech-dispatcher    S01gdm3           S01spice-vdagent
S01anacron              S01grub-common    S01ssh
S01apache2              S01kerneloops     S01sssd
S01apport               S01mono-xsp4      S01sysstat
S01binfmt-support       S01open-vm-tools  S01unattended-upgrades
S01bluetooth            S01openvpn        S01uuidd
S01console-setup.sh     S01plymouth       S01whoopsie
S01cron                 S01rsync
S01cups                 S01saned
// 파일에서 S로 시작하면 재부팅 시 시작하는 스크립트
K로 시작하면 종료 스크립트



case "변수" in
a)
 echo "a 출력"
;;
b)
 echo "b 출력"
;;
*)
 echo "다시"
;;
esac


root@elk:/etc/init.d# vi iptables 
#!/bin/bash

case "$1" in
        start)
                echo "iptables starting..."
                sleep 1
                iptables-restore /etc/iptables.conf
                ;;
        stop)
                echo "iptables stop...."
                sleep 1
                iptables -F
                iptables -t nat -F
                ;;
        restart)
                echo "iptables restart.."
                sleep 1
                iptables -F
                iptables -t nat -F
                iptables-restore /etc/iptables.conf
                ;;
        *)
                echo "ex) iptables (start|stop|restart)"
                ;;

esac
exit 0

root@elk:/etc/init.d# /etc/init.d/iptables start
root@elk:/etc/init.d# iptables -nL
root@elk:/etc/init.d# /etc/init.d/iptables stop
root@elk:/etc/init.d# iptables -nL
// 정책 확인



- 이전버전에서는 기본으로 /etc/rc.local 이 활성화 되었지만 최근 버전은 직접 활성화 해 주어야 한다.
- rc.local(윈도우는 시작프로그램) 은 부팅시에 자동으로 실행하고 싶은 명령을 작성하여 실행한다.

# egrep -r "rc.local" /etc/*  
# vi /etc/rc.local
#!/bin/bash
/etc/init.d/iptables start 2>> /var/log/iptables.err
exit 0

# chmod 700 /etc/rc.local
# systemctl enable rc-local.service
# vi /lib/systemd/system/rc-local.service
[Install]
WantedBy=multi-user.target
# systemctl enable rc-local
# systemctl start rc-local

- 재부팅후 iptables 확인(자동으로 실행 된다.)


ㅁㅊ오늘 월요일임? 구라...


root@elk:/home/roror# vi /etc/dhcp/dhcpd.conf 
 10 option domain-name "dns.google.com";
 11 option domain-name-servers 8.8.8.8,8.8.4.4;
 12 
 13 default-lease-time 600;
 14 max-lease-time 7200;
113 subnet 192.168.1.0 netmask 255.255.255.0 {
114   range 192.168.1.10 192.168.1.20;
115   option routers 192.168.1.1;
116   option broadcast-address 192.168.1.255;
117 } 

root@elk:/home/roror# systemctl start isc-dhcp-server

# cat /var/lib/dhcp/dhcpd.leases
hardware ethernet 00:0c:29:cd:76:c3;   // 192.168.1.10 mac주소 확인

root@elk:/var/log# tail syslog


root@elk:/home/roror# vi /etc/dhcp/dhcpd.conf 
host fantasia {
  hardware ethernet 00:0c:29:cc:34:1e;    // 맥 사용자는 아래의 IP를  고정하여 사용한다.
  fixed-address 192.168.1.10;
}

sudo /etc/init.d/networking restart












