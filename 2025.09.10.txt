echo = ping
echo request: 8
echo reply: 0


Switch(config)#do show mac-address-table   // mac주소 확인
          Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----

   1    0001.c918.6d03    DYNAMIC     Fa0/1
   1    000b.beac.b59e    DYNAMIC     Fa0/4  // DYNAMIC상태
Switch(config)#mac ?
  address-table  Configure the MAC address table
Switch(config)#mac address-table ?
  static  static keyword
Switch(config)#mac address-table static 000b.beac.b59e ?
  vlan  VLAN keyword
Switch(config)#mac address-table static 000b.beac.b59e vlan 1 ?
  interface  interface
Switch(config)#mac address-table static 000b.beac.b59e vlan 1 interface f0/4 // VLAN 1의 Fa0/4 포트에 MAC 000b.beac.b59e를 STATIC으로 고정
Switch(config)#do show mac-address-table
          Mac Address Table
-------------------------------------------

Vlan    Mac Address       Type        Ports
----    -----------       --------    -----

   1    0001.c918.6d03    DYNAMIC     Fa0/1
   1    000b.beac.b59e    STATIC      Fa0/4  // mac주소 고정(STATIC)





플러딩이랑 브로드캐스트랑 다른건가..
Broadcast
송신자가 처음부터 모든 장비에게 보내려고 하는 것
MAC 주소가 FF:FF:FF:FF:FF:FF 인 경우
같은 VLAN 안의 모든 포트로 전송됨
Flooding
송신자가 특정 장비한테 보내려 했는데, 스위치가 목적 MAC 주소를 모를 때 일어남
스위치가 MAC 테이블에 기록이 없으면, 일단 모든 포트로 뿌려서(플러딩) 대상이 응답하게 만듦
응답이 오면 그제서야 스위치가 MAC 주소를 학습하고 테이블에 등록 → 그 다음부터는 Flooding 안 하고 Unicast으로 전송




1) STP에서 스위치는 ROOT Brideg(스위치), N(none)-ROOT Bridge(스위치)로 구분
2) N-ROOT에서 ROOT Bridge로 가는 가장 좋은 Port는 ROOT Port이다.
3) ROOT Bridge 에 연결된 포트(STP)는 기본적으로 Designated Port 이다.(déziɡnèitid : 지정된)
  (1) 각 Segment마다 Designated Port 결정(ROOT로가는 가장 빠른 포트)
  (2) 스위치 <--- Segment(구간) -----> 스위치
  (3) Designated Port(녹색) 와 Blocking Port(주황색) (맥주소가 낮은 값이 우선)
  (4) #show spanning-tree 를 이용하여 차단된 포트 확인 가능(Altn BLK 19)
  (5) #show version  (기본 맥 주소 확인)

* 스패닝 트리(Spanning-Tree)란?  최근에는 RSTP(Rapid STP)를 사용하나 아직 STP도 사용
  - 루프가 생기는 것을 방지하기 위한 프로토콜. 스위치의 이중화(Redundant)시 사용한다. 
     루프가 발생하는걸 막기 위해서 이중화 구성된 라인을 논리적으로 한 부분만 포트를 막아준다. 
     만약 사용중인 라인에 문제가 생기면 논리적으로 막은 포트를 다시 열어서 링크를 연결시켜 준다.
  - (Loop구조) -> Broadcast --> Flooding ---> Looping ---> Storm 발생
 
* 802.1D (STP = Spanning Tree Protocol).
  - 스패닝 트리의 기본적인 프로토콜.
  - BPDU(Bridge Protocol Data Unit) 패킷 구성.

- Root Bridge.
    1) VLAN 마다 하나의 Root Bridge 가 존재한다.
    2) 루트 브릿지의 선택 요소는 BPDU의 Root ID / Bridge ID 이다.
- BPDU(Bridge ID)
    1) 기본적인 Bridge ID
         Bridge Priority (2 Bytes)  MAC Address (6 Bytes)
    2) 확장 ID를 포함한 Bridge ID
         Bridge Priority (4 bits)   Extend System ID(12 bits)   MAC Address (48 bits)

 
  - Bridge ID의 Bridge Priority 부분.
Priority (4 bits)   VLAN Number (12 bits)
    1) Priority : 스위치의 Priority 값이 들어간다. 최저값인 0000 은 0, 0001 은 4096이다.
       (2진수 : 0001 0000 0000 0000, 4096) (2진수 : 1000 0000 0000 0000, 32768)
       이유는 앞에 VLAN 비트가 12비트가 붙어오기 때문이다. 기본값은 8(1000=32768) 이다. 
       최저값 4096 기준으로 반드시 *2 계산하여 8192, 16384, 32768 식으로 계산하여야 한다. 
    2) VLAN Number : VLAN 번호가 들어간다. 2의 12승까지 가능하므로 0 - 4095, 즉 4096개의 구성이 가능하다는 것이다.
    예제) VLAN 번호가 20 이고, Priority 가 32768 이라면 32768 + 20 = 32788, 브릿지 ID는 32788 이 된다.
 
 - STP 구성.
    1) Switch(config)# spanning-tree vlan 1 {root primary}  (스패닝 트리를 VLAN 1번에 구성한다. root primary 는 옵션으로, 이 스위치를 루트 브릿지로 지정한다. 수동으로 루트 브릿지를 구성시에 사용한다.)
    2) Switch(config)# spanning-tree vlan 1 {root secondary)     (위와 마찬가지지만, 옵션에 root secondary 는 스위치를 루트 브릿지 백업으로 만들겠다는 뜻이다.)
    3) Switch(config)# spanning tree vlan 1 priority 8192     (스패닝 트리 VLAN 1번 설정의 priority 값을 8192으로 설정하겠다는 뜻이다. 위에도 설명했지만 이 명령어를 입력하지 않으면 기본값은 32768이 된다.)


S1(config)#spanning-tree vlan 1 priority 4096



- vlan
Switch(config)#interface fastethernet 0/1
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 10
Switch(config-if)#int fa0/2
Switch(config-if)#sw mo ac
Switch(config-if)#sw ac vl 10
Switch(config-if)#int fa0/4
Switch(config-if)#sw mo ac
Switch(config-if)#sw acc vl 20
Switch(config-if)#int fa0/3
Switch(config-if)#sw m a
Switch(config-if)#sw a v 20

--------------------------------------------
- Sample 11
Switch(config)#vlan 10
Switch(config-vlan)#vlan 20
Switch(config-vlan)#int f0/1
Switch(config-if)#sw mo acc
Switch(config-if)#sw acc vl 10
Switch(config-if)#int fa0/3
Switch(config-if)#switchport mode access
Switch(config-if)#switchport access vlan 20

Switch(config)#vlan 10
Switch(config-vlan)#vlan 20
Switch(config-vlan)#
Switch(config-vlan)#int fa0/1
Switch(config-if)#sw mo acc
Switch(config-if)#sw acc vl 10
Switch(config-if)#int fa0/2
Switch(config-if)#sw mo acc
Switch(config-if)#sw acc vl 20



서로 다른 네트워크 연결하려면 선을? 두개 연결해야함..
하나의 케이블로 두개의 내트워크를 연결해주는 기능 : Trunking설정

Trunking 설정 : Inter-VLAN을 이용하여 하나의 물리적인 인터페이스를 여러개의 VLAN의 논리적인 인터페이스로 나누었다.
이를 다시 서로간에 통신할 수 있는 하나의 인터페이스로 소속시키는 것을 트렁킹(Trunking)라 하고, 이처럼 논리적으로 분할된 해당포트를 트렁크 포트라고 한다.
앞에서 언급한 토플로지를 보면 PC0, PC1, PC2 의 모든 포트는 스위치와 연결되어 있고 이 스위치는 fa0/1 번의 인터페이스를 통하여 라우터와 연결된 것을 확인 할 수 있다. 이러한 토플로지인 경우 스위치에서 라우터와 연결된 fa0/1인터페이스 포트를 트렁크 포트로 설정하여 트렁킹을 하게 된다.

Switch(config)#interface gigabitEthernet 0/1
Switch(config-if)#switchport mode trunk

Switch(config-if)#int g0/1
Switch(config-if)#sw mo tr



-------------------------------------------------------------------------------------------
process ID : PID --> RAM에 저장? 암기..
부팅 단계
ROM BIOS에서 어쩌고...

ls -a
.  으로 시작하면 (숨김)파일/디렉토리 이다.
. 은 자기 자신이다.   (pwd)
..  상위(부모)디렉토이 이다.
 - 리눅스의 자료구조는 tree 구조이다.
 - $ tree / | more


cd ./etc랑 cd etc랑 뭐가 다른거...
./를 쓰면 더 정확하다.. 굳이?

roror@localhost:~/etc$ ls -l /etc/passwd
-rw-r--r--. 1 root root 2319  9월  9일  14:31 /etc/passwd
File Type, Permission, Link Count, Owner, Group, File Size, Last Modify Data, File Name
1) File Type : - 파일, d 디렉토리, s 소켓, l 심볼릭링크, p 파이프, b 블럭, c 장치
2) r(4) : 읽기, w(2) 쓰기, x(1)  실행    ----     rw-(6, user, u), r--(4, group, g), r--(4, other, o)
3) . : selinux, facl ( + 등으로 표기된다.)
4) 1    :   Hard link Cound(개수) (몇개의 하드링크를 사용하는가?)
5) root root : 사용자(소유자) 그룹소유자
6) 2319 : 파일 크기
7) 9월  9일  14:31 : 마지막으로 수정한 시간
 - 1,7 i-node의 관리하는 내용이다.
i-node가 뭔데 마지막으로 수정한 시간? 파일 생성한 시간? 
파일명은 디렉토리가 관리..? 무너소리지..

i-node 자체 = 디스크 안에 저장된 자료구조 (숫자 ID와 속성 정보).
ls -l 출력 = i-node에 기록된 정보를 사람이 보기 쉽게 해석한 것.

i-node에 저장되는 정보
파일 종류 (일반파일, 디렉토리, 링크, 소켓 등)
파일 권한 (rwx)
소유자 (UID), 그룹 (GID)
파일 크기 (바이트 단위)
파일의 링크 수 (hard link 개수)
시간 정보
ctime (Change time) : i-node 변경 시각
mtime (Modify time) : 파일 내용 변경 시각
atime (Access time) : 마지막 접근 시각
데이터 블록의 위치(실제 파일 내용이 저장된 디스크 블록 주소)



CLI (Command Line Interface) : 명령어 기반의 텍스트 입출력 인터페이스
Terminal : 서버의 로컬 또는 원격으로 접속할 수 있는 콘솔을 구현한 소프트웨어(Ctrl + Shift + t,n,w,q)
Shell : 명령어를 해석하여 전달해주는 소프트웨어
console : 서버의 로컬 장치에서 직접 명령어를 작성할 수 있는 입출력 장치
tty (Tele Type Writer) : 콘솔 및 터미널 환경 
pts (Pseudo-Terminal Slave) : 원격 터미널 환경
pty (Pseudo-Terminal) : 가상 터미널 환경 (pty는 마스터(master)와 슬레이브(slave) 쌍으로 구성되며, 마스터는 터미널 에뮬레이터나 제어 프로세스가 관리하고, 슬레이브는 사용자 세션이 연결되는 쪽이다.)
가상콘솔 지원 : Ctrl + Alt + F1 ~ Ctrl + Alt + F6   X-Windows(Ctrl + Alt + F7  최근은 Ctrl + Alt + F1 & Alt + Fn 도 가능)

- 리눅스는 확장자가 없다. 파일 타입으로 확인한다.
  즉! 장치든... 프로세스든.... 파일로 확인된다.



- 버전관리/현상관리
  GIT/SVN....
$ git clone https://github.com/juice-shop/juice-shop.git
rm ( 파일 삭제)
rm -r (디렉토리 삭제 가능,  -f  강제로 묻지말고 삭제)

--------------------------------------------
github juice-shop // 검색 버전 같은파일 다운로드(다운로드한 버전:22)
# dnf install nodejs* -y
# gunzip juice-shop-19.0.0_node22_linux_x64.tgz
# tar tvf juice-shop-19.0.0_node22_linux_x64.tar   // 압축 풀기 테스트
# tar xvf juice-shop-19.0.0_node22_linux_x64.tar -C /usr/local/ 
# cd $_    ($_ 는 이전(마지막) 경로를 기억하고 있다.)
# mv juice-shop_19.0.0 juice-shop   (이동, 이름변경)
# cd juice-shop/
# pwd
/usr/local/juice-shop
# npm start
$ netstat -antp | grep 3000
# firewall-cmd --permanent --add-port=3000/tcp
# firewall-cmd --reload
# firewall-cmd --list-all

