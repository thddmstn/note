
슈퍼데몬, 독립데몬..

pstree -p  // pid랑 같이 출력해줌

root@roror:/home/roror# who -r
         런레벨 5  2025-11-03 09:18
root@roror:/home/roror# runlevel
N 5
// /etc/inittab
// 0: halt
// 1: 싱글유저모드
// 2: 다중사용자모드
// 3: 완정 다중사용자모드 (multi-user.target)
// 4: 미지정
// 5: GUI환경(X-window 같은 환경)
// 6: 재부팅
// systemctl get-default
// systemctl set-default multi-user.target

root@roror:/home/roror# joutnalctl -u sshd

root@roror:/home/roror# vi /etc/rsyslog.conf 

root@roror:/home/roror# timedatectl
root@roror:/home/roror# timedatectl list-timezones 
root@roror:/home/roror# timedatectl set-timezone Asia/Seoul 

root@roror:/home/roror# localectl
root@roror:/home/roror# localectl list-locales 
root@roror:/home/roror# echo $LANG
ko_KR.UTF-8

hostnamectl

root@roror:/home/roror# systemctl is-enabled sshd  // 활성화 확인
root@roror:/home/roror# systemctl list-unit-files     
root@roror:/home/roror# systemctl list-unit-files --state=enabled | grep sshd

systemctl list-unit-files  // 모든 서비스 목록보기
systemctl status|enable|disable|start|stop|restart|reload
//            상태|활성화|비활성화|실행|중지|재실행|설정 갱신

root@roror:/home/roror# systemctl enable telnet.socket
root@roror:/home/roror# systemctl start telnet.socket
root@roror:/home/roror# systemctl stop sshd
root@roror:/home/roror# systemctl start sshd.socket
// .socket : 서비스 사용할때만? 실행됨  슈퍼데몬
// .service : 항상 켜져있음..   standalone

// .service 시스템상에서 동작하는 서비스 또는 데몬과 연관된 유닛
// .target 
// .socket 프로세스들의 통신을 위한 소켓, IPC(Inter-process communication)를 위해 사용하는 소켓과 연관된 유닛

온디맨드 방식..?
systemd에서 온디맨드로 데몬을 실행하기 위해 소켓(*.socket)과 서비스(*.service)가 필요하다.

root@roror:/etc/systemd/system/multi-user.target.wants# systemctl disable sshd
Removed '/etc/systemd/system/multi-user.target.wants/sshd.service'.
root@roror:/etc/systemd/system/multi-user.target.wants# systemctl enable sshd
Created symlink '/etc/systemd/system/multi-user.target.wants/sshd.service' → '/usr/lib/systemd/system/sshd.service'.

root@roror:/run# ls // 현재 구동하고있는? 프로그램? 뭔..



root@roror:/etc/systemd/system/
root@roror:/run/systemd/system/
root@roror:/usr/lib/systemd/system/
// 부팅 시 순서대로 파일 확인..?

root@roror:/usr/lib/systemd/system# ls -l runlevel*
root@roror:/usr/lib/systemd/system/graphical.target.wants# ls
systemd-update-utmp-runlevel.service

epel........ㅠ

root@roror:~# dnf install inotify-tools

root@roror:~# vi /usr/local/bin/mylog-watcher.sh
#!/bin/bash

LOG_DIR="/var/log"
OUT_FILE="/var/log/important.log"
# inotifywait: 리눅스의 inotify 기능을 이용한 실시간 파일 시스템 감시 도구 (실시간 감시이므로 cron보다 반응성이 좋다.)
#           -m: 지속적으로 감시 (monitor),  -e create -e modify: 파일이 생성되거나 수정될 때만 반응
#           감시 결과는 표준 출력으로 나오기 때문에, 이걸 파이프로 다음 단계로 넘긴다.
inotifywait -m "$LOG_DIR" -e create -e modify |     
while read path action file; do    # inotifywait가 출력하는 내용을 받아서, 한 줄씩 경로, 동작, 파일명으로 분해해서 처리
  if [[ "$file" == *"secure"* || "$file" == *"auth.log"* ]]; then 
  # 만약 변경된 파일 이름이 secure 또는 auth.log를 포함하면, 이건 보안 관련 로그이므로 중요하다고 판단해서 따로 기록한다.  우분투, 레디햇계열 상관없이 동작하게끔 or문을 사용함
    echo "$(date) - $file was $action" >> "$OUT_FILE"
  # 현재 시간 + 어떤 파일이 어떤 동작을 했는지 출력, 결과를 important.log 파일에 누적(append) 저장
  fi
done
// 로그 디렉토리를 감시, 특이(변경)생기면 로그를 저장하는 간단한 스크립트

* : 0,1,~
+: 1,~
? : 0,1


root@roror:/var/log# vi /etc/systemd/system/mylog-watcher.service
  1 [Unit]
  2 Description=Custom Log Watcher Service
  3 After=nerwork.target
  4 
  5 [Service]
  6 ExecStart=/usr/local/bin/mylog-watcher.sh  // 실행 스크립트
  7 Restart=always  // 종료되면 알아서 재시작
  8 User=root   // 특정사용자로 실행
  9 
 10 [Install]
 11 WantedBy=multi-user.target   // 텍스트모드로 실행

root@roror:/var/log# systemctl daemon-reload
root@roror:/var/log# systemctl start mylog-watcher
root@roror:/var/log# ps -ef | grep mylog


root@roror:/etc/systemd/system# vi /etc/inittab  // 런레벨과 관련된 파일
root@roror:/etc/systemd/system# vi /etc/fstab 

telinit 3 
init 6 // 재부팅

tcp_wrapper
hosts.allow
hosts.deny

xinetd 기반 서비스 주요 설정 항목
disable


root@roror:/etc/rc.d# ls
init.d  rc.local   // rc.local 파일 실행파일로 만들어야함.. 모르겠따..
root@roror:/etc/rc.d# systemctl list-unit-files | grep rc-local
rc-local.service                                                          static          -
// static을 enable로 만들어야 껏다 킬 때 rc.가 실행된다..?

root@roror:/etc/rc.d# echo $?
0


cwd : 디렉토리
exe : 프로그램 자체 링크


root@roror:/proc# cd -P self
root@roror:/proc/3553# ls
root@roror:/proc/3553# ls -l /proc/self
lrwxrwxrwx. 1 root root 0 Nov  3 11:42 /proc/self -> 4202
root@roror:/proc/3553# ls -l /proc/self
lrwxrwxrwx. 1 root root 0 Nov  3 11:42 /proc/self -> 4219

root@roror:~# bash -c 'echo $$;ls -l /proc/self;echo Test OK'
4271
lrwxrwxrwx. 1 root root 0 Nov  3 11:42 /proc/self -> 4272
Test OK
root@roror:~# bash -c 'echo $$;exec ls -l /proc/self;echo Test OK'
4267
lrwxrwxrwx. 1 root root 0 Nov  3 11:42 /proc/self -> 4267




초기의 리눅스는 ext파일 시스템 사용. 리눅스 커널 2.4버전부터는 저널링 파일 시스템 기능이 있는 ext3를 사용.
저널링 파일 시스템은 파일 시스템에 대한 변경사항을 반영하기 전에 저널이라 부느를 로그에 변경사항을 저장하여 추적이 가능하게 만든 파일 시스템이다.

파일 시스템 종류

파일 시스템 구성
부트블럭
아이노드  // 아이노드에는 파일 이름이 없다
디렉토리  // 


fdisk /dev/nvme0n1

Command (m for help): n   // 새로운 파티션 생성
Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-41943039, default 2048): 
Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-41943039, default 41943039): 

Created a new partition 1 of type 'Linux' and of size 20 GiB.

Command (m for help): t   // 파티션 유형 변경
Selected partition 1
Hex code or alias (type L to list all): 8e
Changed type of partition 'Linux' to 'Linux LVM'.

w입력해서 종료



// i : 리눅스에서

root@roror:/home/roror# lsblk -l
NAME           MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sr0             11:0    1 1024M  0 rom  
almalinux-root 253:0    0   44G  0 lvm  /
almalinux-swap 253:1    0    5G  0 lvm  [SWAP]
nvme0n1        259:0    0   20G  0 disk 
nvme0n2        259:1    0   50G  0 disk 
nvme0n2p1      259:2    0    1M  0 part 
nvme0n2p2      259:3    0    1G  0 part /boot
nvme0n2p3      259:4    0   49G  0 part 
nvme0n1p1      259:5    0   20G  0 part 






cp -a /etc/ /backup


root@roror:/home/roror# vi /etc/fstab 
 15 /dev/nvme0n1p1                          /backup                   xfs     defaults        0 0


/etc/fstab
dump관련 설정
파일점검옵션

LABEL=/
UUID=
/dev/sdb1

백업

DISK 검사

blkid  // 파일시스템의 UUID 값을 출력

ㅠㅠㅠㅠ......

mkfs   // 파일시스템 작성
포멧?
-t 옵션 : 작성할 파일 시스템을 선택한다

mke2fs   // 포멧  (xfs는 포멧할 수 없음. mkfs는 가능)

root@roror:/home/roror# mkfs.ex
mkfs.exfat  mkfs.ext2   mkfs.ext3   mkfs.ext4   
root@roror:/home/roror# mkfs.xfs 

fsck   // 파일 시스템 점검
//   /lost + found에 임시로 작성.  fsck에 저장

blkid
lsblk -f
/dev/nvme0n2p1: UUID="0c6df58e-86bd-4372-af64-25256239037a" BLOCK_SIZE="512" TYPE="xfs" PARTUUID="00bf3f28-01"

파일시스템장치명
LABEL=/
/dev/sdb1
UUID

sda sdb sdc ..
sda1 
sda2   => 파티션
sda3

fdisk
w : 저장
n : 새로운 파티션 생성
q : 나가기
l : 파티션 타입 출력
t : 파티션 타입 변경



extended가 있어야함..

df -h


[root@localhost mnt]# df -h

[root@localhost mnt]# cat /etc/mtab

[root@localhost mnt]# cp -a /home/* /backup

/dev/nvme0n2p1          /home                   ext4    defaults        0 0



































































































